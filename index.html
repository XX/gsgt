<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>Graphics by Squares: a Gfx-rs Tutorial</title>
  <style type="text/css">code{white-space: pre;}</style>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
  </style>
  <link rel="stylesheet" href="pandoc.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
  <!-- <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      jax: ["input/TeX", "output/HTML-CSS"],
      MathML: {
        extensions: ["content-mathml.js"]
      },
      "HTML-CSS": { webFont: "Neo-Euler" }
    });
  </script> -->
</head>
<body>
<header>
<h1 class="title">Graphics by Squares: a Gfx-rs Tutorial</h1>
</header>
<p>I'm making a little toy to understand gfx-rs better. But as a side product, I also write this little tutorial to help other people to learn gfx-rs too.</p>
<h2 id="getting-started">Getting started</h2>
<p>Let's write something that compiles and runs.</p>
<pre><code>$ cargo init sqtoy</code></pre>
<p>Add this to <code>Cargo.toml</code>:</p>
<pre class="toml"><code>[dependencies]
gfx = &quot;0.16&quot;
gfx_window_glutin = &quot;0.16&quot;
glutin = &quot;0.8&quot;</code></pre>
<p>And put this into <code>main.rs</code>:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>macro_use<span class="at">]</span> <span class="kw">extern</span> <span class="kw">crate</span> gfx;

<span class="kw">extern</span> <span class="kw">crate</span> gfx_window_glutin;
<span class="kw">extern</span> <span class="kw">crate</span> glutin;

<span class="kw">use</span> gfx::traits::FactoryExt;
<span class="kw">use</span> gfx::Device;
<span class="kw">use</span> gfx_window_glutin <span class="kw">as</span> gfx_glutin;

<span class="kw">pub</span> <span class="kw">type</span> ColorFormat = gfx::format::Rgba8;
<span class="kw">pub</span> <span class="kw">type</span> DepthFormat = gfx::format::DepthStencil;

<span class="kw">const</span> BLACK: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">4</span><span class="op">]</span> = <span class="op">[</span><span class="dv">0.0</span>, <span class="dv">0.0</span>, <span class="dv">0.0</span>, <span class="dv">1.0</span><span class="op">]</span>;

<span class="kw">pub</span> <span class="kw">fn</span> main() <span class="op">{</span>
    <span class="kw">let</span> events_loop = glutin::EventsLoop::new();
    <span class="kw">let</span> builder = glutin::WindowBuilder::new()
        .with_title(<span class="st">&quot;Square Toy&quot;</span>.to_string())
        .with_dimensions(<span class="dv">800</span>, <span class="dv">800</span>)
        .with_vsync();
    <span class="kw">let</span> (window, <span class="kw">mut</span> device, <span class="kw">mut</span> factory, main_color, <span class="kw">mut</span> main_depth) =
        gfx_glutin::init::&lt;ColorFormat, DepthFormat&gt;(builder, &amp;events_loop);

    <span class="kw">let</span> <span class="kw">mut</span> encoder: gfx::Encoder&lt;_, _&gt; = factory.create_command_buffer().into();

    <span class="kw">let</span> <span class="kw">mut</span> running = <span class="cn">true</span>;
    <span class="kw">while</span> running <span class="op">{</span>
        events_loop.poll_events(|glutin::Event::WindowEvent<span class="op">{</span>window_id: _, event<span class="op">}</span>| <span class="op">{</span>
            <span class="kw">use</span> glutin::WindowEvent::*;
            <span class="kw">match</span> event <span class="op">{</span>
                KeyboardInput(_, _, <span class="cn">Some</span>(glutin::VirtualKeyCode::Escape), _)
                | Closed =&gt; running = <span class="cn">false</span>,
                Resized(_, _) =&gt; <span class="op">{</span>
                    gfx_glutin::update_views(&amp;window, &amp;<span class="kw">mut</span> main_color, &amp;<span class="kw">mut</span> main_depth);
                <span class="op">}</span>,
                _ =&gt; (),
            <span class="op">}</span>
        <span class="op">}</span>);

        encoder.clear(&amp;main_color, BLACK);
        encoder.flush(&amp;<span class="kw">mut</span> device);
        window.swap_buffers().unwrap();
        device.cleanup();
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>As you can see, we use gfx with glutin and OpenGL. Shortly what the code does:</p>
<ol>
<li>Creates an event loop and prepares to create a window with title “Square Toy”</li>
<li>Runs <code>gfx_window_glutin::init()</code> to get <code>glutin::Window</code>, <code>gfx_device_gl::Device</code> and a bunch or other things</li>
<li>Uses the <code>factory</code> to create an <code>Encoder</code> that allows you to avoid calling raw OpenGL procedures.</li>
<li>Each frame:
<ol>
<li>Check whether it's the time to exit</li>
<li>Fill the screen with the color you want (it's <code>BLACK</code>)</li>
<li>Actually do it.</li>
<li>Since our buffering is at least double, switch buffers</li>
<li>Cleanup</li>
</ol></li>
</ol>
<p>Great! Whatever you use, it is always simple to draw a black screen full of nothing. Unfortunately, drawing something else is usually a little bit more complicated. In gfx-rs it requires a pipeline, vertices, shaders...</p>
<h2 id="overview-of-gfx-rs-architecture">Overview of gfx-rs architecture</h2>
<p><img src="https://i.imgur.com/Dgj7PX8.jpg" /></p>
<p>Gfx-rs is a library that abstracts over four low-level graphics APIs: OpenGL (ordinary and ES), DirectX, Metal and Vulkan. Because of that, it cannot provide a direct API to do things. Neither it should though, as graphics APIs (especially older one like OpenGL) are extremely verbose, imperative and stateful. Also they are neither safe nor easy to use.</p>
<p>In gfx-rs, everything is built around three core types: <code>Factory</code>, <code>Encoder</code> and <code>Device</code>. The first is used to create things, the second is a buffer that stores graphics commands to be executed by the <code>Device</code>, and the <code>Device</code> translates commands into low-level API calls.</p>
<p>Also, like current-get API like DX12 and Vulcan but unlike OpenGL, the pipeline state is incapsulated in pipeline state objects (PSO). You can have a lot of PSOs and switch between them. But to create a PSO, first you have to define a pipeline and specify vertex atributes and uniforms.</p>
<p>There's a <a href="https://gfx-rs.github.io/2016/09/14/programming-model.html">great post</a> in Gfx-rs blog describing Gfx-rs architecture in much more detail.</p>
<h2 id="drawing-a-square">Drawing a square</h2>
<p>We need a pipeline to draw anything on the screen.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">gfx_defines!</span> <span class="op">{</span>
    vertex Vertex <span class="op">{</span>
        pos: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">2</span><span class="op">]</span> = <span class="st">&quot;a_Pos&quot;</span>,
        color: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">3</span><span class="op">]</span> = <span class="st">&quot;a_Color&quot;</span>,
    <span class="op">}</span>

    pipeline pipe <span class="op">{</span>
        vbuf: gfx::VertexBuffer&lt;Vertex&gt; = (),
        out: gfx::RenderTarget&lt;ColorFormat&gt; = <span class="st">&quot;Target0&quot;</span>,
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>In graphics programming, everything is made of triangles and triangles are defined by their vertices. Vertices can carry additional information beside the coordinates, ours have only 2D position <code>a_Pos</code> and color <code>a_Color</code>. The pipeline has only the vertex buffer and the render target, no textures, no transformations, nothing fancy.</p>
<p>The GPU doesn't know what <em>exactly</em> to do with the vertices and what color pixels should have. To define the behaviour <em>shaders</em> are used. There're two kinds of shaders vextex shaders and fragment shaders (let's ignore geometric shaders we don't use). Both are executed in parallel on the GPU. A vertex shader runs on each vertex and transfroms it in a some way. A fragment shader runs on each fragment (usually pixel) and determinates what the color the fragment will have.</p>
<p>Our vertex shader is very, very simple:</p>
<div class="sourceCode"><pre class="sourceCode glsl"><code class="sourceCode glsl"><span class="co">// shaders/rect_150.glslv</span>
<span class="pp">#version 150 core</span>

<span class="dt">in</span> <span class="dt">vec2</span> a_Pos;
<span class="dt">in</span> <span class="dt">vec3</span> a_Color;
<span class="dt">out</span> <span class="dt">vec4</span> v_Color;

<span class="dt">void</span> <span class="fu">main</span>() {
    v_Color = <span class="dt">vec4</span>(a_Color, <span class="fl">1.0</span>);
    <span class="bu">gl_Position</span> = <span class="dt">vec4</span>(a_Pos, <span class="fl">0.0</span>, <span class="fl">1.0</span>);
}</code></pre></div>
<p>OpenGL uses <code>(x, y, z, w)</code> <a href="http://www.tomdalling.com/blog/modern-opengl/explaining-homogenous-coordinates-and-projective-geometry/">homogeneous coordinates</a> and RGBA colors. The shader just translates <code>a_Pos</code> and <code>a_Color</code> into OpenGL position and color.</p>
<p>The fragment shader is even more simple:</p>
<div class="sourceCode"><pre class="sourceCode glsl"><code class="sourceCode glsl"><span class="co">// shaders/rect_150.glslf</span>
<span class="pp">#version 150 core</span>

<span class="dt">in</span> <span class="dt">vec4</span> v_Color;
<span class="dt">out</span> <span class="dt">vec4</span> Target0;

<span class="dt">void</span> <span class="fu">main</span>() {
    Target0 = v_Color;
}</code></pre></div>
<p>It just sets the pixel color to <code>v_Color</code> value <a href="http://www.geeks3d.com/20130514/opengl-interpolation-qualifiers-glsl-tutorial/">interpolated</a> from vertices <code>v_Color</code> values by the GPU.</p>
<p>Let's define our vertices:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">const</span> WHITE: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">3</span><span class="op">]</span> = <span class="op">[</span><span class="dv">1.0</span>, <span class="dv">1.0</span>, <span class="dv">1.0</span><span class="op">]</span>;

<span class="kw">const</span> SQUARE: <span class="op">[</span>Vertex; <span class="dv">3</span><span class="op">]</span> = <span class="op">[</span>
    Vertex <span class="op">{</span> pos: <span class="op">[</span><span class="dv">0.5</span>, -<span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span>-<span class="dv">0.5</span>, -<span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span>-<span class="dv">0.5</span>, <span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>
<span class="op">]</span>;</code></pre></div>
<p>And initalize everything we need for drawing:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> <span class="kw">mut</span> encoder: gfx::Encoder&lt;_, _&gt; = factory.create_command_buffer().into();
<span class="kw">let</span> pso = factory.create_pipeline_simple(
    <span class="pp">include_bytes!</span>(<span class="pp">concat!</span>(<span class="pp">env!</span>(<span class="st">&quot;CARGO_MANIFEST_DIR&quot;</span>), <span class="st">&quot;/shaders/rect_150.glslv&quot;</span>)),
    <span class="pp">include_bytes!</span>(<span class="pp">concat!</span>(<span class="pp">env!</span>(<span class="st">&quot;CARGO_MANIFEST_DIR&quot;</span>), <span class="st">&quot;/shaders/rect_150.glslf&quot;</span>)),
    pipe::new()
).unwrap();
<span class="kw">let</span> (vertex_buffer, slice) = factory.create_vertex_buffer_with_slice(&amp;SQUARE, ());
<span class="kw">let</span> <span class="kw">mut</span> data = pipe::Data <span class="op">{</span>
    vbuf: vertex_buffer,
    out: main_color
<span class="op">}</span>;</code></pre></div>
<p>Since <code>main_color</code> is moved into <code>data</code>, we need to replace <code>&amp;main_color</code> with <code>&amp;data.out</code> everywhere. And then, in the event loop, we draw:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">encoder.clear(&amp;data.out, BLACK);
encoder.draw(&amp;slice, &amp;pso, &amp;data);
encoder.flush(&amp;<span class="kw">mut</span> device);</code></pre></div>
<p>And the program was run.</p>
<p><img src="https://i.imgur.com/7u3ol88.png" width="600" height="600" /></p>
<p>This is not a square. The reason why it is not a square is simple: it has three vertices, so it must be a triange. Also OpenGL doesn't know anything about squares, it can only draw triangles.</p>
<p>You could just add three more vertices to draw a square by two triangles. Like this:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">const</span> SQUARE: <span class="op">[</span>Vertex; <span class="dv">6</span><span class="op">]</span> = <span class="op">[</span>
    Vertex <span class="op">{</span> pos: <span class="op">[</span><span class="dv">0.5</span>, -<span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span>-<span class="dv">0.5</span>, -<span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span>-<span class="dv">0.5</span>, <span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span>-<span class="dv">0.5</span>, <span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span><span class="dv">0.5</span>, <span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span><span class="dv">0.5</span>, -<span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
<span class="op">]</span>;</code></pre></div>
<p>But instead we can define just 4 vertices and reuse them with Element Buffer Objects.</p>
<p><img src="http://www.opengl-tutorial.org/assets/images/tuto-9-vbo-indexing/indexing1.png" /></p>
<p>So let's define vertices and indices:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">const</span> SQUARE: &amp;<span class="op">[</span>Vertex<span class="op">]</span> = &amp;<span class="op">[</span>
    Vertex <span class="op">{</span> pos: <span class="op">[</span><span class="dv">0.5</span>, -<span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span>-<span class="dv">0.5</span>, -<span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span>-<span class="dv">0.5</span>, <span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
    Vertex <span class="op">{</span> pos: <span class="op">[</span><span class="dv">0.5</span>, <span class="dv">0.5</span><span class="op">]</span>, color: WHITE <span class="op">}</span>,
<span class="op">]</span>;

<span class="kw">const</span> INDICES: &amp;<span class="op">[</span><span class="dt">u16</span><span class="op">]</span> = &amp;<span class="op">[</span><span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">0</span><span class="op">]</span>;</code></pre></div>
<p>And use them:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">let</span> (vertex_buffer, slice) =
    factory.create_vertex_buffer_with_slice(SQUARE, INDICES);</code></pre></div>
<p>Compile the program and run.</p>
<p><img src="https://i.imgur.com/5JfHmm6.png" width="600" height="600" /></p>
<p>Finally, a square. The most basic thing is done, now we can do further.</p>
<h2 id="going-deeper">Going deeper</h2>
<p>The first thing you should notice is that the square we drew is actually a rectangle: when you resize the window proportions change. That's because OpenGL uses <em>normalized</em> coordinates where both x and y are from –1 to 1. So we need to adjust the square vertices to the window ratio.</p>
<p>The second thing is: our vertices and indices are pre-defined and constant. We can't adjust them, we can't make new squares on the fly.</p>
<p>Let's fix both of these issues. Define a vertice generator:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">,</span> <span class="bu">Clone</span><span class="at">,</span> <span class="bu">Copy</span><span class="at">)]</span>
<span class="kw">struct</span> Square <span class="op">{</span>
    <span class="kw">pub</span> pos: (<span class="dt">f32</span>, <span class="dt">f32</span>),
    <span class="kw">pub</span> size: <span class="dt">f32</span>,
    <span class="kw">pub</span> color: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">3</span><span class="op">]</span>
<span class="op">}</span>

<span class="co">// A cube is a pile of infinitely (as continuum) many squares</span>
<span class="co">// This data stucture is finite, so we call it “pseudo”</span>
<span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">)]</span>
<span class="kw">struct</span> Pseudocube <span class="op">{</span>
    squares: <span class="dt">Vec</span>&lt;Square&gt;,
    ratio: <span class="dt">f32</span>,
<span class="op">}</span>

<span class="kw">impl</span> Pseudocube <span class="op">{</span>
    <span class="kw">pub</span> <span class="kw">fn</span> new() -&gt; <span class="kw">Self</span> <span class="op">{</span>
        Pseudocube <span class="op">{</span>
            squares: <span class="pp">vec!</span><span class="op">[]</span>,
            ratio: <span class="dv">1.0</span>,
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="kw">pub</span> <span class="kw">fn</span> add_square(&amp;<span class="kw">mut</span> <span class="kw">self</span>, x: <span class="dt">f32</span>, y: <span class="dt">f32</span>, size: <span class="dt">f32</span>, color: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">3</span><span class="op">]</span>) <span class="op">{</span>
        <span class="kw">let</span> sq = Square <span class="op">{</span>
            pos: (x, y),
            size, color
        <span class="op">}</span>;
        <span class="kw">self</span>.squares.push(sq);
    <span class="op">}</span>

    <span class="kw">pub</span> <span class="kw">fn</span> get_vertices_indices(&amp;<span class="kw">self</span>) -&gt; (<span class="dt">Vec</span>&lt;Vertex&gt;, <span class="dt">Vec</span>&lt;<span class="dt">u16</span>&gt;) <span class="op">{</span>
        <span class="kw">let</span> (<span class="kw">mut</span> vs, <span class="kw">mut</span> is) = (<span class="pp">vec!</span><span class="op">[]</span>, <span class="pp">vec!</span><span class="op">[]</span>);
        <span class="kw">for</span> (i, sq) <span class="kw">in</span> <span class="kw">self</span>.squares.iter().enumerate() <span class="op">{</span>
            <span class="kw">let</span> (pos, half) = (sq.pos, <span class="dv">0.5</span> * sq.size);
            <span class="kw">let</span> i = i <span class="kw">as</span> <span class="dt">u16</span>;

            <span class="kw">let</span> (hx, hy);
            <span class="kw">if</span> <span class="kw">self</span>.ratio &gt; <span class="dv">1.0</span> <span class="op">{</span>
                hx = half / <span class="kw">self</span>.ratio;
                hy = half;
            <span class="op">}</span>
            <span class="kw">else</span> <span class="op">{</span>
                hx = half;
                hy = half * <span class="kw">self</span>.ratio;
            <span class="op">}</span>

            vs.extend(&amp;<span class="op">[</span>
                Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> + hx, pos.<span class="dv">1</span> - hy<span class="op">]</span>, color: sq.color <span class="op">}</span>,
                Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> - hx, pos.<span class="dv">1</span> - hy<span class="op">]</span>, color: sq.color <span class="op">}</span>,
                Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> - hx, pos.<span class="dv">1</span> + hy<span class="op">]</span>, color: sq.color <span class="op">}</span>,
                Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> + hx, pos.<span class="dv">1</span> + hy<span class="op">]</span>, color: sq.color <span class="op">}</span>,
            <span class="op">]</span>);
            is.extend(&amp;<span class="op">[</span>
                <span class="dv">4</span>*i, <span class="dv">4</span>*i + <span class="dv">1</span>, <span class="dv">4</span>*i + <span class="dv">2</span>, <span class="dv">4</span>*i + <span class="dv">2</span>, <span class="dv">4</span>*i + <span class="dv">3</span>, <span class="dv">4</span>*i
            <span class="op">]</span>);
        <span class="op">}</span>

        (vs, is)
    <span class="op">}</span>

    <span class="kw">pub</span> <span class="kw">fn</span> update_ratio(&amp;<span class="kw">mut</span> <span class="kw">self</span>, ratio: <span class="dt">f32</span>) <span class="op">{</span>
        <span class="kw">self</span>.ratio = ratio
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>And use it:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">pub</span> <span class="kw">fn</span> main() <span class="op">{</span>
    <span class="kw">let</span> <span class="kw">mut</span> cube = Pseudocube::new();
    cube.add_square(<span class="dv">0.0</span>, <span class="dv">0.0</span>, <span class="dv">1.0</span>, WHITE);
    <span class="co">// ...</span>
    <span class="kw">let</span> (vertices, indices) = cube.get_vertices_indices();
    <span class="kw">let</span> (vertex_buffer, <span class="kw">mut</span> slice) =
        factory.create_vertex_buffer_with_slice(&amp;vertices, &amp;*indices);
    <span class="co">// ...</span>
    <span class="kw">let</span> <span class="kw">mut</span> running = <span class="cn">true</span>;
    <span class="kw">let</span> <span class="kw">mut</span> needs_update = <span class="cn">false</span>;
    <span class="kw">while</span> running <span class="op">{</span>
        <span class="kw">if</span> needs_update <span class="op">{</span>
            <span class="kw">let</span> (vs, is) = cube.get_vertices_indices();
            <span class="kw">let</span> (vbuf, sl) = factory.create_vertex_buffer_with_slice(&amp;vs, &amp;*is);

            data.vbuf = vbuf;
            slice = sl;

            needs_update = <span class="cn">false</span>
        <span class="op">}</span>
        <span class="co">// ...</span>
                Resized(w, h) =&gt; <span class="op">{</span>
                    gfx_glutin::update_views(&amp;window, &amp;<span class="kw">mut</span> data.out, &amp;<span class="kw">mut</span> main_depth);
                    cube.update_ratio(w <span class="kw">as</span> <span class="dt">f32</span> / h <span class="kw">as</span> <span class="dt">f32</span>);
                    needs_update = <span class="cn">true</span>
                <span class="op">}</span>,
        <span class="co">// ...</span>
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>Great. Now our squares are always squares. Time to add some cursor:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="at">#[</span>derive<span class="at">(</span><span class="bu">Debug</span><span class="at">,</span> <span class="bu">Clone</span><span class="at">,</span> <span class="bu">Copy</span><span class="at">)]</span>
<span class="kw">enum</span> Cursor <span class="op">{</span>
    Plain((<span class="dt">f32</span>, <span class="dt">f32</span>), <span class="op">[</span><span class="dt">f32</span>; <span class="dv">3</span><span class="op">]</span>),
    Growing((<span class="dt">f32</span>, <span class="dt">f32</span>), <span class="dt">f32</span>, <span class="op">[</span><span class="dt">f32</span>; <span class="dv">3</span><span class="op">]</span>)
<span class="op">}</span>

<span class="kw">impl</span> Cursor <span class="op">{</span>
    <span class="kw">fn</span> to_square(<span class="kw">self</span>) -&gt; Square <span class="op">{</span>
        <span class="kw">match</span> <span class="kw">self</span> <span class="op">{</span>
            Cursor::Plain(xy, color) =&gt; Square <span class="op">{</span> pos: xy, size: <span class="dv">0.05</span>, color <span class="op">}</span>,
            Cursor::Growing(xy, size, color) =&gt; Square <span class="op">{</span> pos: xy, size, color <span class="op">}</span>,
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>

<span class="co">// ...</span>

<span class="kw">impl</span> Pseudocube <span class="op">{</span>
<span class="co">// ...</span>
    <span class="kw">pub</span> <span class="kw">fn</span> update_cursor_position(&amp;<span class="kw">mut</span> <span class="kw">self</span>, x: <span class="dt">f32</span>, y: <span class="dt">f32</span>) <span class="op">{</span>
        <span class="kw">let</span> x = <span class="dv">2.0</span>*x - <span class="dv">1.0</span>;
        <span class="kw">let</span> y = -<span class="dv">2.0</span>*y + <span class="dv">1.0</span>;
        <span class="kw">let</span> cursor = <span class="kw">match</span> <span class="kw">self</span>.cursor <span class="op">{</span>
            Cursor::Plain(_, color) =&gt; Cursor::Plain((x, y), color),
            Cursor::Growing(_, size, color) =&gt; Cursor::Growing((x, y), size, color),
        <span class="op">}</span>;
        <span class="kw">self</span>.cursor = cursor;
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// ...</span>
                Resized(w, h) =&gt; <span class="op">{</span>
                    gfx_glutin::update_views(&amp;window, &amp;<span class="kw">mut</span> data.out, &amp;<span class="kw">mut</span> main_depth);
                    cube.update_ratio(w <span class="kw">as</span> <span class="dt">f32</span> / h <span class="kw">as</span> <span class="dt">f32</span>);
                    window_size = (w <span class="kw">as</span> <span class="dt">f32</span>, h <span class="kw">as</span> <span class="dt">f32</span>);
                    needs_update = <span class="cn">true</span>
                <span class="op">}</span>,
                MouseMoved(x, y) =&gt; <span class="op">{</span>
                    cube.update_cursor_position(
                        x <span class="kw">as</span> <span class="dt">f32</span> / window_size.<span class="dv">0</span>,
                        y <span class="kw">as</span> <span class="dt">f32</span> / window_size.<span class="dv">1</span>
                    );
                    needs_update = <span class="cn">true</span>
                <span class="op">}</span>,</code></pre></div>
<p>It's alive. <strong>IT'S ALIVE!</strong> Yeah, things always becomes more cool when you add a little bit of interactivity.</p>
<p>Let's grow squares:</p>
<pre class="toml"><code>[dependencies]
rand = &quot;*&quot;</code></pre>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">impl</span> Pseudocube <span class="op">{</span>
<span class="co">// ...</span>
    <span class="kw">pub</span> <span class="kw">fn</span> start_growing(&amp;<span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span>
        <span class="kw">if</span> <span class="kw">let</span> Cursor::Plain(xy, color) = <span class="kw">self</span>.cursor <span class="op">{</span>
            <span class="kw">self</span>.cursor = Cursor::Growing(xy, <span class="dv">0.05</span>, color)
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="kw">pub</span> <span class="kw">fn</span> stop_growing(&amp;<span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span>
        <span class="kw">if</span> <span class="kw">let</span> Cursor::Growing(xy, size, color) = <span class="kw">self</span>.cursor <span class="op">{</span>
            <span class="kw">self</span>.squares.push (Cursor::Growing(xy, size, color).to_square());
            <span class="kw">self</span>.cursor = Cursor::Plain(xy, rand::random())
        <span class="op">}</span>
    <span class="op">}</span>

    <span class="kw">pub</span> <span class="kw">fn</span> tick(&amp;<span class="kw">mut</span> <span class="kw">self</span>) <span class="op">{</span>
        <span class="kw">if</span> <span class="kw">let</span> Cursor::Growing(xy, size, color) = <span class="kw">self</span>.cursor <span class="op">{</span>
            <span class="kw">self</span>.cursor = Cursor::Growing(xy, size + <span class="dv">0.01</span>, color)
        <span class="op">}</span>
    <span class="op">}</span>
<span class="op">}</span>
<span class="co">// ...</span>
                MouseInput(ElementState::Pressed, MouseButton::Left) =&gt;
                    cube.start_growing(),
                MouseInput(ElementState::Released, MouseButton::Left) =&gt;
                    cube.stop_growing(),
                _ =&gt; (),
            <span class="op">}</span>

            cube.tick();</code></pre></div>
<p>And squares were grown:</p>
<p><img src="https://i.imgur.com/rumV7tU.png" width="600" height="600" /></p>
<h2 id="textures-and-uniforms">Textures and uniforms</h2>
<p>So, you can draw squares, you can move cursor around, what else do you need? Oh, I see. Graphics. Plain colors are boring, right? Let's add some <a href="https://learnopengl.com/#!Getting-started/Textures">texturing</a>:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="pp">gfx_defines!</span> <span class="op">{</span>
    vertex Vertex <span class="op">{</span>
        pos: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">2</span><span class="op">]</span> = <span class="st">&quot;a_Pos&quot;</span>,
        uv: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">2</span><span class="op">]</span> = <span class="st">&quot;a_Uv&quot;</span>,
        color: <span class="op">[</span><span class="dt">f32</span>; <span class="dv">3</span><span class="op">]</span> = <span class="st">&quot;a_Color&quot;</span>,
    <span class="op">}</span>

    pipeline pipe <span class="op">{</span>
        vbuf: gfx::VertexBuffer&lt;Vertex&gt; = (),
        awesome: gfx::TextureSampler&lt;<span class="op">[</span><span class="dt">f32</span>; <span class="dv">4</span><span class="op">]</span>&gt; = <span class="st">&quot;t_Awesome&quot;</span>,
        out: gfx::RenderTarget&lt;ColorFormat&gt; = <span class="st">&quot;Target0&quot;</span>,
    <span class="op">}</span>
<span class="op">}</span></code></pre></div>
<p>There are two changes here. The first is: vertices have got a new data: <code>a_Uv</code>. And if you think this can mean only one thing, you're right: yes, GPU doesn't know how to <em>exactly</em> draw textures. And yes, we use a fragment shader to determinate the behavior. <code>a_Uv</code> are coordinates of a texture fragment.</p>
<p>The second change introduces <code>t_Awesome</code> texture in the pipeline. The texture is the same for all triangles drawn with this pipeline. But what if you want different squares to look different? Well, there're three ways. The first way is to switch textures for each square. This ways is slow because it requires a draw call for each square, you can't draw everything with one call. The second way is to put everything into one big texture (a texture atlas) and use uv coordinates to get a texture from the atlas. The third way is to use a texture array (if it's supported).</p>
<p>We'll use neither of these ways, so our squares will have the same simple texture:</p>
<p><img src="https://i.imgur.com/40VzkBZ.jpg" /></p>
<p>So let's texture our squares. To do it, we need a crate to load images:</p>
<pre class="toml"><code>[dependencies]
image = &quot;*&quot;</code></pre>
<p>And we need to modify our shaders a little bit:</p>
<div class="sourceCode"><pre class="sourceCode glsl"><code class="sourceCode glsl"><span class="pp">#version 150 core</span>

<span class="dt">in</span> <span class="dt">vec2</span> a_Pos;
<span class="dt">in</span> <span class="dt">vec2</span> a_Uv;
<span class="dt">in</span> <span class="dt">vec3</span> a_Color;
<span class="dt">out</span> <span class="dt">vec4</span> v_Color;
<span class="dt">out</span> <span class="dt">vec2</span> v_Uv;

<span class="dt">void</span> <span class="fu">main</span>() {
    v_Color = <span class="dt">vec4</span>(a_Color, <span class="fl">1.0</span>);
    v_Uv = a_Uv;
    <span class="bu">gl_Position</span> = <span class="dt">vec4</span>(a_Pos, <span class="fl">0.0</span>, <span class="fl">1.0</span>);
}</code></pre></div>
<div class="sourceCode"><pre class="sourceCode glsl"><code class="sourceCode glsl"><span class="pp">#version 150 core</span>

<span class="kw">uniform</span> <span class="dt">sampler2D</span> t_Awesome;

<span class="dt">in</span> <span class="dt">vec4</span> v_Color;
<span class="dt">in</span> <span class="dt">vec2</span> v_Uv;
<span class="dt">out</span> <span class="dt">vec4</span> Target0;

<span class="dt">void</span> <span class="fu">main</span>() {
    <span class="dt">vec3</span> aw = <span class="bu">texture</span>(t_Awesome, v_Uv).<span class="fu">rgb</span>;

    <span class="kw">if</span>(aw == <span class="dt">vec3</span>(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>)) {
        Target0 = <span class="fl">0.20</span> * v_Color;
    } <span class="kw">else</span> {
        Target0 = <span class="dt">vec4</span>(aw, <span class="fl">1.0</span>);
    }
}</code></pre></div>
<p>And copypaste a function from <a href="https://wiki.alopex.li/LearningGfx">an another tutorial</a>:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust"><span class="kw">fn</span> load_texture&lt;F, R&gt;(factory: &amp;<span class="kw">mut</span> F, path: &amp;<span class="dt">str</span>) -&gt; gfx::handle::ShaderResourceView&lt;R, <span class="op">[</span><span class="dt">f32</span>; <span class="dv">4</span><span class="op">]</span>&gt;
    <span class="kw">where</span> F: gfx::Factory&lt;R&gt;, R: gfx::Resources
<span class="op">{</span>
    <span class="kw">let</span> img = image::open(path).unwrap().to_rgba();
    <span class="kw">let</span> (width, height) = img.dimensions();
    <span class="kw">let</span> kind = gfx::texture::Kind::D2(width <span class="kw">as</span> <span class="dt">u16</span>, height <span class="kw">as</span> <span class="dt">u16</span>, gfx::texture::AaMode::Single);
    <span class="kw">let</span> (_, view) = factory.create_texture_immutable_u8::&lt;ColorFormat&gt;(kind, &amp;<span class="op">[</span>&amp;img<span class="op">]</span>).unwrap();
    view
<span class="op">}</span></code></pre></div>
<p>Add uv coordinates to vertices:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">                Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> + hx, pos.<span class="dv">1</span> - hy<span class="op">]</span>, uv: <span class="op">[</span><span class="dv">1.0</span>, <span class="dv">0.0</span><span class="op">]</span>, color: sq.color <span class="op">}</span>,
                Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> - hx, pos.<span class="dv">1</span> - hy<span class="op">]</span>, uv: <span class="op">[</span><span class="dv">0.0</span>, <span class="dv">0.0</span><span class="op">]</span>, color: sq.color <span class="op">}</span>,
                Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> - hx, pos.<span class="dv">1</span> + hy<span class="op">]</span>, uv: <span class="op">[</span><span class="dv">0.0</span>, <span class="dv">1.0</span><span class="op">]</span>, color: sq.color <span class="op">}</span>,
                Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> + hx, pos.<span class="dv">1</span> + hy<span class="op">]</span>, uv: <span class="op">[</span><span class="dv">1.0</span>, <span class="dv">1.0</span><span class="op">]</span>, color: sq.color <span class="op">}</span>,</code></pre></div>
<p>And load the texture:</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">    <span class="kw">let</span> texture = load_texture(&amp;<span class="kw">mut</span> factory, <span class="st">&quot;assets/awesome.png&quot;</span>);
    <span class="kw">let</span> sampler = factory.create_sampler_linear();

    <span class="kw">let</span> <span class="kw">mut</span> data = pipe::Data <span class="op">{</span>
        vbuf: vertex_buffer,
        awesome: (texture, sampler),
        out: main_color
    <span class="op">}</span>;</code></pre></div>
<p>Ta-da:</p>
<p><img src="https://i.imgur.com/jeKLvoc.png" width="600" height="600" /></p>
<p>Oh no. The black is still black and the image is upside down. Well, the first is the bug of the image itself (that's what you get for downloading JPEG from the Internet), but why it's upside down?</p>
<p>Well, the reason is simple. Image coordinates have y-axis up-down, while in OpenGL y axis is always down-up. So the most obvious solution is to flip the image. But there's a more simple way: we can flip uv coordinates instead.</p>
<div class="sourceCode"><pre class="sourceCode rust"><code class="sourceCode rust">Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> + hx, pos.<span class="dv">1</span> - hy<span class="op">]</span>, uv: <span class="op">[</span><span class="dv">1.0</span>, <span class="dv">1.0</span><span class="op">]</span>, color: sq.color <span class="op">}</span>,
Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> - hx, pos.<span class="dv">1</span> - hy<span class="op">]</span>, uv: <span class="op">[</span><span class="dv">0.0</span>, <span class="dv">1.0</span><span class="op">]</span>, color: sq.color <span class="op">}</span>,
Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> - hx, pos.<span class="dv">1</span> + hy<span class="op">]</span>, uv: <span class="op">[</span><span class="dv">0.0</span>, <span class="dv">0.0</span><span class="op">]</span>, color: sq.color <span class="op">}</span>,
Vertex <span class="op">{</span> pos: <span class="op">[</span>pos.<span class="dv">0</span> + hx, pos.<span class="dv">1</span> + hy<span class="op">]</span>, uv: <span class="op">[</span><span class="dv">1.0</span>, <span class="dv">0.0</span><span class="op">]</span>, color: sq.color <span class="op">}</span>,</code></pre></div>
<p>And then...</p>
<p><img src="https://i.imgur.com/8li9Csm.png" width="600" height="600" /></p>
</body>
</html>
